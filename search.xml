<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[About Java Wildcard]]></title>
    <url>%2F2019%2FAbout%20Java%20Wildcard%2F</url>
    <content type="text"><![CDATA[前言其实我对于java的泛型一直很迷，它有&lt;T&gt;,&lt;T extends Object&gt;，&lt;? extends Objext&gt;和&lt;? super Object&gt;等形式，对于刚接触泛型的人来说，简直恶意满满。于是昨天开始了恶补模式，把这部分又看了一遍，终于是有所理解，写下此篇以作记录。 由来其实在JVM里泛型是不存在的，你在代码里写的泛型，到了JVM都会被擦除类型，也许会有点懵，泛型擦除又是什么鬼。 Talk is cheap show me the code. 比如我们现在定义fun方法，它可以处理List&lt;Float&gt;或Lins&lt;Double&gt;类型，也就是List&lt;Number的子类&gt;类型的参数，那么你可能会这么写 1234public class Test &#123; public static void fun(List&lt;Float&gt; list) &#123; &#125; public static void fun(List&lt;Double&gt; list) &#123; &#125;&#125; 然后如果你用的是Idea的话，这时候应该会代码报错&#39;fun(List&lt;Float&gt;)&#39; clashes with &#39;fun(List&lt;Double&gt;)&#39;; both methods have same erasure，这句话的意思就是这两个fun方法有相同的泛型擦除。 这里就涉及到泛型擦除的概念了，就如我开头所说的一样，JVM是没有泛型的，那么你写的泛型在JVM里其实是不存在的，在编译成字节码的时候会被擦除掉，也就是List&lt;Object&gt;-&gt;List，所以无论你是List&lt;Float&gt;还是Lins&lt;Double&gt;泛型被擦除以后都是List，那么现在你应该知道为什么会代码报错了，因为在Java里是不能定义一个方法名，参数类型，返回值都一致的多个方法的。 那么如果我想处理所有类型的List怎么办呢 这个时候就需要泛型了 我们可以这样定义fun方法 1public static &lt;T&gt; void fun(List&lt;T&gt; list) &#123;&#125; 这样，我们就可以同时接受List&lt;Float&gt;或Lins&lt;Double&gt;参数了，可是问题又来了，我们在这个方法里的list的item（以下简称为item）是不能使用Float或者Double类型的属性或者方法的，因为我们都不知道T最后会是什么类型，这完全取决于使用这个方法时传进来的参数类型，T甚至可以是String类型，这不就乱套了吗。 进一步推导而且我们又发现了一个奇怪的事情，item竟然是Object类型的，这是为什么呢，我们明明没有传Object类型啊。 首先，我们都知道Object类型是所有类的父类，那么无论T最后会是什么类型都好，它都是Object的子类，也就是说item的类型肯定是Object或者Object的子类，所以Java就会知道item的类型上限是Object类型，从而判断item是Object类型。 这里就引出了&lt;T extends Object&gt;的概念，它和&lt;T&gt;意义是一样的，只不过&lt;T&gt;缩略了extends Object，就如同继承于Object的类可以缩略extends Object一个道理，那么既然可以通过&lt;T extends Object&gt;限定T是Object的子类，那么我们只要把Object改成别的类型，不就可以限定T的类型了吗，我们都知道Float和Double都是Number的子类，那么我们就可以这么写了。 1public static &lt;T extends Number&gt; void fun(List&lt;T&gt; list) &#123;&#125; 而在限定了T的父类以后，我们就可以在item上使用Number的方法和属性了，而且这样就不能传List&lt;String&gt;类型的参数进来了。 但是我们又发现了一个问题。 1List&lt;Number&gt; nums = list; 当我们声明一个List&lt;Number&gt;类型的变量，然后把list赋值给它的时候又报错了，什么鬼？！ 经过观察，我们发现即使T extends Number但List&lt;T&gt;依旧不能赋值给List&lt;Number&gt;，这是因为T是extends Number的，但是List&lt;T&gt;并不extends List&lt;Number&gt;，所以就出现了报错，那么我们该怎么办呢，这个时候通配符就应运而生了。 1List&lt;? extends Number&gt; nums = list; List&lt;? extends Number&gt;可以理解为List&lt;任何继承Number的类&gt;的父类，所以现在nums就可以存放List&lt;T&gt;了，因为它的类型已经是List&lt;T&gt;的父类了。 但是我们又发现了一个奇怪的事情，怎么那么多事情 12nums.add(0.11);Float f = nums.get(0); 这两行报错了，我们一行一行分析为什么会报错。 首先是nums.add(0.11);，为什么不能添加0.11，因为如果能添加0.11，那就能添加111L，因为他们都是Number的子类，但是我们都知道List只接收一种类型，而如果能添加成功，我们就可以添加多种类型了，其实我们可以这样理解，List&lt;? extends Number&gt;是多种List&lt;Number子类&gt;的父类，但是List&lt;T&gt;是唯一的，它只能等于其中一种类型，所以其实他们是冲突的，而解决冲突的方法就是禁止add，这样就不能修改nums，而nums是从明确的List&lt;T&gt;赋值过来的，从而保证nums的类型是唯一的。 然后就是Float f = nums.get(0);，这行报错，是因为T只是extends Number，但并没有明确是哪个子类，所以直接把值赋给Float的肯定不行的，但是我们可以赋值给Number类型，因为Number肯定是T的父类，所以都可以自动转型成Number。 所以说在List&lt;? extends Number&gt;里，只能拿到Number类型的item，而且不能修改列表。 那么List&lt;? super Number&gt;呢，刚好就反过来，因为? super Number代表的是Number的父类，所以我们知道了它的最小类型是Number，也就是可以看作它的item类型是Number或者Object，所以所有Number或者Object的子类都可以自动向上转型赋值给item，也就是可以修改这个列表。但是取出的时候却不是这样了，由于去除的时候我们并不知道这个item的类型，所以Java会按照最大类型判断，也就是说取出的item类型都是Object，因为如果这个item实际类型是Object，但你取出的时候设定是Number的话，就属于向下转型，而Object是缺少子类的一些属性方法的，所以会转型失败，抛出异常，而为了避免这种情况，List&lt;? super Number&gt;只能取出Object类型的item。 总结总的来说就是List&lt;? extends Number&gt;可以取出最小限定类型的item，但为了List的类型唯一，所以不能修改列表。而List&lt;? super Number&gt;只能取出最大类型，也就是Object，而且因为确定最小限定类型，所以所有子类都可以存进列表，也就是可以任意修改列表，但只能通过最大类型去获取item。 扩展所以我们可以发现super其实是很少用到的，而且List&lt;? super Number&gt;使用起来和List&lt;? super Object&gt; List&lt;Object&gt;没啥区别，所以还是Kotlin好用😉]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Blog]]></title>
    <url>%2F2019%2FAbout%20Blog%2F</url>
    <content type="text"><![CDATA[关于你 关于它 关于我 其实我之前是搭建过博客的，说起来这是我第三次搭建了。每次我都会写一篇About Blog，用于说明来意。 第一次搭建，是源于好玩，感觉在Github Page上搭建一个属于自己的博客是一件很有趣的事情。 第二次搭建，是深思熟虑，开始认为应该用博客输出自己所学，记录自己。但最后因为太在意博客的细枝末节了，反而本末倒置，最后不了了之。其实在第二次搭建博客以后我是有写记录的，但是没发表过出来，因为都是些日常碎碎念。技术相关的文章也不是没有，但写的零零散散，不适合阅读。 第三次，也就是这一次，真的应该开始认真写些东西了。 至此，共勉。]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
